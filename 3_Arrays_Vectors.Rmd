---
title: "Arrays"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,error=TRUE,collapse = T)
library(reticulate)

```

<style>
div.python pre { background-color: #FFF3F3
; }
</style>

<style>
div.r pre { background-color: #f8f8ff; }
</style>


This chapter delves deeper into the concepts of arrays and vectors that were introduced in the 'Basics' chapter. In R, everything is included in the base package. The main advantage of using vectors is that it allows for vectorized operations, rather than using loops to perform operations on each element of an object. Vectorized operations allow for more efficient processing of blocks of data.


<p>&nbsp;</p>
<p>&nbsp;</p>

Let's first take a look at an example to understand the benefits of using vectorized operations:

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

vec = c(1:2000000)

t = Sys.time()
vec_2 = vec*2
Sys.time() - t

t = Sys.time()
vec_2_loop <- rep(0,length(vec))
for(i in 1:length(vec)){
  vec_2_loop[i] = vec[i]*2
    }
Sys.time() - t

```

</div>
</div>

# Create arrays 

- Starting from existing list or vector :

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

arr = matrix(c(1, 2, 3, 4), 4, 1)
arr
```

</div>
</div>

- Create arrays with zero, one, sequence..

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

matrix(rep(0,2*3), 2, 3)

matrix(rep(1,2*3), 2, 3)

seq(1,6)

matrix(seq(1,6),2,3)

seq(1, 4, length.out = 10)

```

</div>
</div>


## Random array 


<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

#generate a matrix
mat_rd <- matrix(runif(4*5),4,5)

mat_rd


```

</div>
</div>

## Indexing and slicing

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R


mat <- matrix(1:6,2,3,byrow = T)
mat[1,]
mat[1:2,]
mat[2:dim(mat)[1],]
```

</div>
</div>

## Shape and size
    


<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

# length gives the total number of elements of the array.
length(mat_rd)

```

```{r, collapse = TRUE}
#R

# dim display a vector of integers with the number of elements stored along each dimension of the array
dim(mat_rd)

```

</div>
</div>

# Modifiying arrays

## Add elements 

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R
mat

rbind(mat,7:9)

cbind(mat,7:8)
```

</div>
</div>

- Combining/splitting arrays

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

mat0 = matrix(0,2,3)
mat1 = matrix(1,2,3)

mat01 = rbind(mat0,mat1)
mat01

cbind(mat0,mat1)

# horizontal
asplit(mat01,2)

#vertical
asplit(mat01,1)

```

</div>
</div> 




## Delete elements

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

mat[,-2]

mat[-2,]
```

</div>
</div>

## Sorting


<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

arr <- runif(10)

arr
sort(arr)

```

```{r, collapse = TRUE}
# R

arr <- matrix(runif(4*3),4,3)

arr
apply(arr,MARGIN = 2, FUN = sort)

```

</div>
</div>

# Conditional Logic on array

Imagine you have two square matrices representing interactions between entities. Each matrix represents a basic network, with a value of 1 indicating interaction and 0 indicating no interaction. You want to determine if two entities that are linked in one network are also linked in another network. Instead of checking each entity's interaction sequentially in a loop, you can use matrix operations to perform element-wise calculations and get the same result in a more efficient manner.

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

#generate a sequence
list_1 <- list(c(0,1,0,1),c(1,0,1,0),c(0,1,0,1),c(1,0,1,0))

network_1 <- do.call(rbind,list_1)

#generate a sequence
list_2 = list(c(0,1,0,0),c(1,0,0,0),c(0,0,0,1),c(0,0,1,0))

network_2 <- do.call(rbind,list_2)

network_12 = network_1*network_2
network_12

```

</div>
</div>


## Select specific elements


<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R
 
network_12 > 0

network_12[network_12>0]
```

</div>
</div>

One thing that is commonly needed is to modify specific values in an array that meet a certain condition. The first step is to identify which cells meet the condition. In R, the `which` function is used.


It is important to note that the execution time can change depending on the size of the vector.

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

vec <- seq(1,200000)

t <- Sys.time()
results <- rep(0,length(vec))
for(i in 1:length(vec)){
  if(vec[i]%%2!=0){
    results[i] = 0
  } else {
    results[i] = vec[i]
  }
}
Sys.time() - t


t <- Sys.time()
results <- ifelse(vec%%2!=0,vec,0)
Sys.time() - t

```

```{r, collapse = TRUE}
# R

vec <- seq(1,20000000)

t <- Sys.time()
results <- rep(0,length(vec))
for(i in 1:length(vec)){
  if(vec[i]%%2!=0){
    results[i] = 0
  } else {
    results[i] = vec[i]
  }
}
Sys.time() - t


t <- Sys.time()
results <- ifelse(vec%%2!=0,vec,0)
Sys.time() - t


## other way using which

t <- Sys.time()
vec[which(vec%%2==0)] = 0
Sys.time() - t 

```

</div>
</div>

## Other conditional vectorization 

<div class = "row">
<div class = "r">

```{r,echo = T,collapse = TRUE}
# R
library(dplyr)
# Fast version of ifelse()
x <- c(-3:3, NA)
if_else(condition = x < 0,
        true      = "neg",
        false     = "pos",
        missing   = "NA")


# Vectorised ifelse statements


x <- 1:10
case_when(
  x %% 6 == 0 ~ "fizz buzz",
  x %% 2 == 0 ~ "fizz",
  x %% 3 == 0 ~ "buzz",
  TRUE ~ as.character(x)
)

```

</div>
</div>




# Algebra

<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R

 
X <- do.call(rbind,list(c(0,1,5,1),c(2,1,3,1),c(2,1,9,6),c(7,2,1,0),c(8,3,5,5))) 
Y <- c(0,1,2,5,4)
 
t(X)%*%X

XtX <- t(X)%*%X

# inverse Matrix
solve(XtX)

```

```{r, collapse = TRUE}
# R


XtY = t(X)%*%Y

# OLS 
Beta = solve(XtX) %*% XtY
Beta

```

</div>
</div>


# Operation on array
Operator | Description
-|:-
+ | Addition (e.g., 1 + 1 = 2)
- | Subtraction (e.g., 3 - 2 = 1)
- | Unary negation (e.g., -2)
* | Multiplication (e.g., 2 * 3 = 6)
/ | Division (e.g., 3 / 2 = 1.5)
%/% | Floor division (e.g., 3 %/% 2 = 1)
^ | Exponentiation (e.g., 2 ^ 3 = 8)
%% | Modulus/remainder (e.g., 9 %% 4 = 1)


<div class = "row">
<div class = "r">

```{r, collapse = TRUE}
# R
network_12[!upper.tri(network_12)] = 0
# nb of link
sum(network_12)
# same since there is only 0 and 1 
sum(network_12[which(network_12>0,arr.ind = T)]) # see the arr.ind to get the two coordinates

# share of link 
mean(network_12)


# nb link by entities
apply(network_12,MARGIN = 2,FUN = sum)

# share of link across entities (by columns)
apply(network_12,MARGIN = 2,FUN = mean)


```

</div>
</div>


## Apply familly (R)

The apply() family of functions allows for the manipulation of slices of data from matrices, arrays, lists, and dataframes in a repetitive manner, without the need for explicit use of loop constructs. These functions act on an input list, matrix or array and apply a function with one or several optional arguments.

### apply

apply takes a matrix as input, transform it by row or by columns and returns a matrix

<div class = "r">
<div class = "row">

```{r, collapse = TRUE}
# R

mat_1 = matrix(1:(4*4),4,4)

# by row
apply(mat_1,MARGIN = 1,FUN = sum)

# by columns
apply(mat_1,MARGIN = 2,FUN = function(x){x**2})


```
</div>
</div>

### lapply


lapply takes a list as input, transform it and returns a list.


<div class = "r">

<div class = "row">
```{r, collapse = TRUE}
# R

list_1 = list(mat_1,seq(1,8,0.5))
list_1

# by row
lapply(list_1,FUN = function(x){x**2})

# by columns
lapply(list_1,FUN = sum)


```
</div>
</div>

### sapply

sapply takes a list as input, transform it and returns a matrix.

<div class = "r">

<div class = "row">
```{r, collapse = TRUE}
# R

list_1 = list(mat_1,seq(1,8,length.out = length(mat_1)))
list_1

# by row
sapply(list_1,FUN = function(x){x**2})

# by columns
sapply(list_1,FUN = sum)


```
</div>
</div>


### mapply

mapply is used for 'multivariate' apply, which is used to vectorize arguments to a function that does not typically accept vector arguments. Depending on the size of the outputs, it will return a matrix or a list.

<div class = "r">

<div class = "row">
```{r, collapse = TRUE}
# R

# returns a matrix (all length.out = 5)
mapply(FUN = function(x,y,z){seq(x,y,length.out = z)},1,1:5,5)

# returns a list (length.out goes from 1 to 5)
mapply(FUN = function(x,y,z){seq(x,y,length.out = z)},1,1:5,1:5)


```
</div>
</div>


# Exercises

</div>


<p>&nbsp;</p>
<p>&nbsp;</p>

<div style="border:1px solid; padding:10px; margin-bottom:10px; border-radius: 10px; background-color: #f9f9f9;">

**Exercise 1**

The series, $1^{1} + 2^{2} + 3^{3} + ... + 10^{10} = 10405071317$.

Find the last ten digits of the series, $1^{1} + 2^{2} + 3^{3} + ... + 1000^{1000}$.

</div>


<p>&nbsp;</p>
<p>&nbsp;</p>

<div style="border:1px solid; padding:10px; margin-bottom:10px; border-radius: 10px; background-color: #f9f9f9;">

**Exercise 2**

Try to vectorize exercices from chapter 1, you can also compare it with apply/map functions.

</div>


<p>&nbsp;</p>
<p>&nbsp;</p>

<div style="border:1px solid; padding:10px; margin-bottom:10px; border-radius: 10px; background-color: #f9f9f9;">
 

**Exercise 3**

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

</div>


<p>&nbsp;</p>
<p>&nbsp;</p>

<div style="border:1px solid; padding:10px; margin-bottom:10px; border-radius: 10px; background-color: #f9f9f9;">

**Exercise 4**
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.

Find the largest palindrome made from the product of two 3-digit numbers.


</div>


<p>&nbsp;</p>
<p>&nbsp;</p>


<a href="">Solutions</a> 
<!-- exo_chap_2.html -->

