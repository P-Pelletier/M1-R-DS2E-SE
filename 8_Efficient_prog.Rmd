---
title: "Efficient Programming"
---


<style>
div.python pre { background-color: #e9f7f5
; }
</style>

<style>
div.r pre { background-color: #f8f8ff; }
</style>



This chapter is a very brief introduction to the concepts of matrix sparse which can be useful to optimize RAM usage in some cases. Also it will show how to use the full power of cores present in our computer by initiating students to parallel algebra.



# Sparse Matrix

When dealing with large array that are sparse (lot of element equal to 0), it is inneficient to store this object as a dense matrix. Large matrix are sometimes difficult to store in the memory because they are weighty, when they dealing with sparse we can store it and do calculation with them in a very efficient way using the 'Compressed Sparse Column' (CSC) format. See how it change the weight of the matrix when changing the format to sparse matrix .

<div class = "row">

<div class = "r">

```{r, error=TRUE ,collapse = TRUE}
# R
library(Matrix)

X = matrix(0,10000,10000)
idx = round(runif(1000,1,10000**2))

X[idx] = 1

print(object.size(X),units = 'auto')

sparse_X = Matrix(X,sparse = T)
print(object.size(sparse_X),units = 'auto')
```

```{r, error=TRUE ,collapse = TRUE}
# R
library(tictoc)

tic()
sum_x = X+X
toc()

tic()
sum_sparse_x = sparse_X+sparse_X
toc()
```

</div>
</div>



# Parallel computing

Sometimes the tasks performed successively in a loop are slow, as long as one operation is not finished the computer does not move on to the next one. When the iterations of a loop are independent of each other, i.e. the iteration i+1 is insensitive to the results of the previous iterations, we can use parallel calculation. Your computer is composed of physical processors and logical processors (cores and threads) on which the tasks will be distributed.


Let's make an example where the goal will be to make a bootstrap with a linear model. We will resample 500 times our dataset and estimate a model for each sample. 


Let's create first the dataset

<div class = "row">

<div class = "r">

```{r,error=TRUE , collapse = TRUE}
# R

X = matrix(runif(100000*2),100000,2)
y = 2 + 0.5*X[,1] + 0.2*X[,2] + rnorm(100000,0,3)
```


- Create a function to compute OLS coefficients for a given sample

```{r,error=TRUE , collapse = TRUE}
# R 

lm_bs <- function(){
    idx_sample = sample(seq(1,length(y)))
    y_sample = y[idx_sample]
    X_sample = X[idx_sample,]
    reg = lm(y_sample ~ X_sample)
    coef_s = reg$coefficients[-1]
    return(coef_s)
}

```


- Run bootstrap with a loop

```{r, error=TRUE ,collapse = TRUE}
# R

tic()
coefs = matrix(0,500,2)
for(i in 1:500){
  coefs[i,] = lm_bs()
}
toc()

```

- Check how many cores you can use 

```{r, error=TRUE ,collapse = TRUE}
# R
library(doParallel)
detectCores()
registerDoParallel(5)

```

- Run the loop in parallel !

```{r,error=TRUE , collapse = TRUE}
# R

tic()
coefs =  foreach(i = 1:500,.packages = c('base')) %dopar% {
                   lm_bs()
                   }

toc()


```
</div>
</div>



# Error and Exception Handling

It is important to understand why a given function may produce an error. Determining the situations where errors may occur is not always easy, but it's important to not be too lenient in order to avoid errors. In the examples, we will see how the flexibility of a function can lead to different results, some of which may be more efficient than others.

For example, if we expect that 99% of the time the result will contain something iterable, we would use the try/except approach. This will be faster if exceptions are truly exceptional. However, if the result is None more than 50% of the time, then using an 'if' statement is probably a better approach.

While an 'if' statement always has a cost, setting up a try/except block is relatively inexpensive. However, when an exception does occur, the cost is much higher.

<div class = "row">

<div class = "r">

```{r,error=TRUE ,warning=F}
# R
# Let's create a function that create a list 
create_dirty_list <- function(None_prop){
  list_ <- list()
  for(i in seq(1,10000,1)){
    if(i<None_prop*10000){
      list_[[i]] <- c(NA)
      } else {
      values <- sample(seq(1,10000,1),round(runif(1,1,50)))
      # introduce some character 
      if(i%%10==0){
        values <- as.character(values)
      list_[[i]] <- values
      }
      }
  }
  return(list_)
  }

# randomly take two values to compute the ratio 
calc1 <- function(values){
  output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
  return(output)
}

list_ <- create_dirty_list(0.5)
# Store it in a list
results <- lapply(list_,FUN = calc1)

```

```{r,error=TRUE ,warning=F}
# Let's change the function

calc2 <- function(values){
  if(!any(is.na(values))){
    output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
    return(output)
  }
}


results <- lapply(list_,FUN = calc2)
```

```{r,error=TRUE ,warning=F}
# Let's change the function

calc3 <- function(values){
  if(!any(is.na(values))){
    if(is.numeric(values)){
      output <- values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
      return(output)
    }
  }
}



results <- lapply(list_,FUN = calc3)

```

```{r,error=TRUE ,echo = T,warning=F}
# using try

calc_try <- function(values){
  output <- tryCatch(
    {
      values[round(runif(1,1,length(values)))]/values[round(runif(1,1,length(values)))]
    }
    ,error=function(e){
      return(NA)
    })
  return(output)
}
    
results <- lapply(list_,FUN = calc_try)
```

 - Compare execution time

```{r,error=TRUE ,echo = T,warning=F}
 
list_ <- create_dirty_list(0.01)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```

```{r,error=TRUE ,echo = T,warning=F}
# compare it 
list_ = create_dirty_list(0.33)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```

```{r,error=TRUE ,echo = T,warning=F}
# compare it 
list_ = create_dirty_list(0.75)
t <- Sys.time()
results <- lapply(list_,FUN = calc3)
Sys.time()-t
t <- Sys.time()
results <- lapply(list_,FUN = calc_try)
Sys.time()-t

```
</div>
</div>



